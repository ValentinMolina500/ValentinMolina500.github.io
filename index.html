    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="utf-8" />
            <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <meta name="theme-color" content="#000000" />
            <meta
              name="description"
              content="Web site created using create-react-app"
            />
            <title>Writing MIPS</title>
            <link href="styles.css" rel="stylesheet">
        </head>
        <body>
            <div class="container">
                <h1>Coding in MIPS</h1>
                <p>MIPS code kind of sucks, let's make it not suck.</p>

                <h2>Common MIPS Instructions</h2>
                <p>You know the basic instructions, but let's list them again:</p>

                <ul class="mips-instruction-list">
                    <li>
                        <h3><code>add</code></h3>
                        <code>
                            add $t0, $t1, $t2
                        </code>
                        <p>Computes the sum of the 2nd and 3rd register and stores it in the first register.</p>
                    </li>
                    <li>
                        <h3><code>mult</code></h3>
                        <code>
                            mult $t0, $t1  <br />
                            mflo $t2 
                        </code>
                        <p>
                            Computes the product of two registers and stores the result in the <code>$lo</code> register.
                        </p>
                        <p>
                            Use the instruction <code>mflo</code> (<i>move from lo</i>)
                            to store the result of multiplication in a register.
                        </p>
                    </li>
                    <li>
                        <h3><code>li</code></h3>
                        <code>li $t0, 10</code>
                        <p>
                            This instruction loads a 32-bit integer value into a register.
                            It's what's known as a <strong>psuedo instruction</strong>:
                            it's not actually part of the MIPS architecture, but it's provided
                            by the assembler, usually for convenience. 
                        </p>
        
                        <p>This instruction is handy for storing immediate values into registers.</p>
                    </li>
                    <li>
                        <h3><code>move</code></h3>
                        <code>move $t0, $t1</code>
                        <p>
                            Another pseudo instruction. Copies or <i>moves</i> the value of the 2nd register, into
                            the 1st register.
                        </p>
        
                        <p>
                            This instruction is handy for moving values from registers into <code>$a</code> registers when calling a function,
                            or into <code>$v</code> registers for returning values from functions
                        </p>
                    </li>
                </ul>

                <h2>Working with functions</h2>
                <p>
                    Functions are common place in any programming language.
                    Let's see how to define one in MIPS.
                </p>

                <code>

                    # Defining our function <br>
                    myFunction: <br>
                        add $t0, $a0, $a1 <br>
                        move $v0, $t0 <br>
                        jr $ra <br>

                

                
                    
                </code> 
                
                <p>
                    This is a simple function that adds two numbers and 
                    returns the result.
                </p>
                <p>It may be helpful to see how function would be defined in something like C:</p>

                <code>
                    int myFunction(int a, int b) { <br>
                        int c = a + b; <br>
                        return c; <br>
                    }
                </code>

                <p>These two functions are functionally equivalent.</p>
                <h3>What the heck are <code>$a</code> registers?</h3>
                <p>
                    It's convention in MIPS to store arguments to functions in MIPS 
                    in <code>$a</code> register (<code>$a0</code>, <code>$a1</code> etc.)
                </p>

                <p>
                    For example, let's say you want to call <code>myFunction</code> in MIPS to add the numbers 2 and 4:
                </p>

                <code>
                    myFunction: <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;add $t0, $a0, $a1 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;move $v0, $t0 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jr $ra <br>

                    <br>

                    # Loading values into our argument registers <br>
                    li $a0, 2 <br>
                    li $a1, 4 <br>

                    <br>

                    # Calling our function with arguments 2, 4 <br>
                    jal myFunction <br>

                </code>

                <p>Let's walk through this example:</p>

                <code>
                    li $a0, 2 <br>
                    li $a1, 4 <br>
                </code>

                <p>
                    Here we are storing the numbers 2 and 4 in <code>$a0</code>
                    and <code>$a1</code> respectively. This is because want to add those
                    numbers with our function.
                </p>

                <code>
                    myFunction: <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;add $t0, $a0, $a1 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;move $v0, $t0 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jr $ra <br>

                </code>

                <p>
                    Remember our function adds the numbers in the <code>$a0</code> and <code>$a1</code> register,
                    that's why we're storing 2 and 4 in <code>$a0</code>
                    and <code>$a1</code>!
                </p>

                <p>What if I wanted to add 5 and 9?</p>

                <code>
                    li $a0, 5 <br>
                    li $a1, 9 <br>
                </code>

                <p>Beautiful.</p>

                <code>
                    jal myFunction <br>
                </code>

                <p>With our arguments stored in <code>$a0</code>
                    and <code>$a1</code>, we're ready to call
                    our function with the <code>jal</code> 
                    instruction.
                </p>

                <p>
                    This instruction does two main things:

                    <ul>
                        <li>
                            Stores where the program is in execution in the <code>$ra</code> register
                        </li>
                        <li>
                            Jumps to where our function is defined
                        </li>
                    </ul>
                </p>

                <p>
                    Why store where the program is in <code>$ra</code>?
                    That's because we want to return to where we called 
                    the function after the function is called.
                </p>

                <p>
                    In memory speak, we are storing the <i>address</i> of
                    where we were in our code in <code>$ra</code>.
                </p>

                <code>
                    myFunction: <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;add $t0, $a0, $a1 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;move $v0, $t0 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jr $ra <br>
                </code>

                <p>
                    After the <code>jal</code> instruction, we jump to our function code.
                    We run the <code>add</code> instruction to add our <code>$a0</code> and <code>$a1</code> registers
                    and store in <code>$t0</code>. Remember <code>$a0</code> and <code>$a1</code> have the numbers 
                    we want to add: 2 and 4.
                </p>

                <p>
                    Next, we use the <code>move</code> instruction to 
                    move the result of our addition into our return value register
                    <code>$v0</code>. So that would hold 6 in this case!
                </p>

                <p>
                    Lastly, we use the <code>jr</code> instruction to jump
                    to our <code>$ra</code> register, which if you remember, holds
                    the location of where we called <code>myFunction</code>:
                </p>

                <code>
                    jal myFunction <br>
                </code>

                <p>So we would be back here and continue going through our code as usual.</p>

                <p>
                    Again, let's see how this would look like in C:
                </p>

                <code>
                    // define our function <br>
                    int myFunction(int a, int b) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;int c = a + b; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;return c; <br>
                    }
                    <br><br>

                    // Calling our function with arguments 2, 4 <br>
                    myFunction(2, 4);
                    <br> <br>
                    // Contine in our code 
                </code>

                <p>
                    Again, this is functionally equivalent to our call in MIPS.
                </p>

                <p> A lot of times, we call a function and stores it's result in a variable:</p>

                <code>
                    int i = myFunction(2, 4);
                </code>

                <p>
                    To do this in MIPS, remember <code>$v</code> registers hold return values for functions.
                </p>

                <code>
                    ...

                    <br><br>

                    li $a0, 2 <br>
                    li $a1, 4 <br>
                    <br>
                    jal myFunction <br>
                    <br>
                    move $t0, $v0
                </code>

                <p>
                    Here we call our function with numbers 2 and 4, and then
                    use the <code>move</code> instruction to register <code>$t0</code>
                </p>

                <p>
                    We've defined a function and called it in MIPS! Not too crazy huh?
                </p>

                <h2>Rules for writing functions</h2>
                <p>
                    If you're not writing a function that calls another function, 
                    there are three things to keep in mind
                </p>

                <ul>
                    <li>
                        If your function uses arguments, they will be available in 
                        the <code>$a</code> registers. Thus, when calling these functions
                        you must store the values you want to use as arguments in the <code>$a</code>
                        registers.
                    </li>
                    <li>
                        If your function returns values, store them in <code>$v</code> registers
                    </li>
                    <li>
                        Your function must return to where it was called with the <code>jr</code> instruction 
                        and the <code>$ra</code> register
                    </li>
                </ul>

                <p>
                    These rules work for simple functions that don't call other function,
                    but what if you want to call another function?
                </p>

                <h2>Stack pointers and nested functions</h2>
                <p>
                    Whenever a function calls another functions, we say that 
                    the function has nested function(s).
                </p>

                <p>Let's see what that looks like in MIPS:</p>

                <code>
                    function1: <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;add $t0, $t1, $t2 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jal function2 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jr $ra <br>
                    <br> 
                    function2: <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;add $t0, $t1, $t2 <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;jr $ra

                    
                </code>

                <p>
                    Here, <code>function1</code> calls <code>function2</code>, so function1 has nested functions.
                    Special care is required when dealing with functions that call other functions.
                </p>

                <p>
                    Let's see what happens when we call <code>function1</code> as it is now with:
                </p>

                <code>
                    jal function1
                </code>

                <p>
                    This instruction will jump to our <code>function1</code> code and 
                    <strong>stores the current location of this line in <code>$ra</code></strong>
                </p>
                
                <code>
                    function1: <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;add $t0, $t1, $t2 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jal function2 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jr $ra <br>
                </code>

                <p>The first line is some example code, we can ignore it.</p>
                <p>
                    The second line calls function2 and <strong>stores the current location of this line in <code>$ra</code></strong>.
                </p>
                <p>
                    See the problem here? 
                </p>

                <p>
                    We've overwritten <code>$ra</code> in function1!
                </p>

                <p>Why is that a problem? Well let's continue going line by line:</p>

                <code>
                    function2: <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;add $t0, $t1, $t2, <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jr $ra
                </code>

                <p>
                    This function adds some stuff and then uses <code>jr</code>
                    to jump to <code>$ra</code>. This works fine, it holds the location of line:
                    
                </p>

                <code>
                    jal function2 <br>
                </code>

                <p>
                    So using <code>jr $ra</code> in <code>function2</code> takes us back there:
                </p>

                <code>
                    function1: <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;add $t0, $t1, $t2 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jal function2 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jr $ra <br>
                </code>

                <p>
                    But the next line in <code>function1</code> is another <code>jr $ra</code>.
                    Remeber <code>$ra</code> holds the location of:
                </p>

                <code>
                    jal function2 <br>
                </code>

                <p>
                    So the line <code>jr $ra</code> in function1 <strong>takes us back to that line:</strong>
                </p>

                <p>
                    You see the problem there? We're going to run the command <code>jal function2</code> again.
                    What we wanted to do really was get back to where we originally called function1, or:
                </p>

                <code>
                    jal function1
                </code>

                <p>
                    This is the problem of calling a function within another function, since <code>jal</code> writes
                    to the <code>$ra</code> register, the <code>$ra</code> register will get overwritten
                    with each function call.
                </p>

                <p>What we have to do is store the value <code>$ra</code> before we call another function.</p>

                <p>There is a special register made for this purpose, the <code>$sp</code> register or <i>stack pointer register</i>.</p>

                <p>
                    The solution is quite simple, we add 4 lines of code to <code>function1</code>:
                </p>

                <code>
                    function1: <br>
                    <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;# save our first $ra in $sp <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;addi $sp, $sp, -4<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;sw $ra, 0($sp) <br>
                    <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;add $t0, $t1, $t2 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jal function2 <br>
                    <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;# restore $ra from $sp <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;lw $ra, 0($sp)<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;addi $sp, $sp, 4<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jr $ra <br>

                    <br> 
                    function2: <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;add $t0, $t1, $t2 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;jr $ra

                    
                </code>

                <p>Let's explain:</p>
                <code>
                    addi $sp, $sp, -4<br>
                    sw $ra, 0($sp) <br>
                </code>
                <p>
                    First, we make some space on stack, by setting <code>$sp</code>
                    equal to <code>$sp</code> - 4.
                </p>
                <p>
                    Remember, <code>$ra</code> is a location in 
                    our code, a memory address. A memory address is 32-bits long in MIPS.
                    Remember, bytes are 8-bits long.
                </p>

                <p>
                    So we need to make space for 4 bytes on <code>$sp</code>. Since <code>$sp</code>
                    starts at the very top of our memory space, we <i>subtract</i> 4 to make space.

                </p>

                <p>
                    The next line, <code>sw</code>, we store our return address, <code>$ra</code>
                    in <code>$sp</code>.
                </p>

            <code>
                lw $ra, 0($sp)<br>
            </code>

            <p>
                We do our addition, call <code>function2</code> and are now ready
                to return out of <code>function1</code>
                </p>
                <p>
                    Before, we were screwed. But not this time, because we stored our original <code>$ra</code>
                    in <code>$sp</code>.
                </p>

                <p>
                    It doesn't matter that <code>function2</code> overwrote <code>$ra</code>
                    we can retrieve it's value with <code>lw</code>. Since we saved <code>$ra</code>
                    at <code>0($sp)</code>, we can get it back by loading that data at <code>0($sp)</code>
                </p>

                <code>
                    addi $sp, $sp, 4<br>
                </code>

                <p>
                    Before returning out of <code>function1</code>, we have some clean up to do.

                </p>
                <p>


                    Since we made space intially in the stack to save <code>$ra</code>, we have to return
                    that space back. We subtracted 4, so now we have to add 4 to <code>$sp</code>.
                </p>

                <code>
                    jr $ra
                </code>

                <p>
                    Finally, we can now <code>jr</code> to <code>$ra</code> in <code>function1</code> addition
                    return to the line that called <code>function1</code> initially.
                </p>

                <h3>Rules with nested functions summarized</h3>
                <p>
                    If you're writing a function that calls another function, 
                    keep these in keep in mind
                </p>

                <ul>
                    <li>
                        If your function uses arguments, they will be available in 
                        the <code>$a</code> registers. Thus, when calling these functions
                        you must store the values you want to use as arguments in the <code>$a</code>
                        registers.
                    </li>
                    <li>
                        If your function returns values, store them in <code>$v</code> registers
                    </li>
                    <li>
                        Your function must return to where it was called with the <code>jr</code> instruction 
                        and the <code>$ra</code> register
                    </li>
                    <li>
                        Before calling a function, make space on the stack pointer and save <code>$ra</code>
                    </li>
                    <li>
                        Before returning from a function, make sure to restore <code>$ra</code> from <code>$sp</code> and
                        cleaning up the space you made on <code>$sp</code>
                    </li>
                </ul>
            </div>
        </body>
    </html>