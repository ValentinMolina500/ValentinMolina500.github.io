<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <link rel="stylesheet" href="./vendor/highlight-js/styles/atom-one-light.css">
     
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="theme-color" content="#000000" />
        <meta
          name="description"
          content="Web site created using create-react-app"
        />
        <title>Writing MIPS</title>
        <link href="styles.css" rel="stylesheet">
    </head>
    <body>
        <div class="container">
            <h1>Memory in MIPS Explained</h1>

            <p>
                Memory in the MIPS architecture is something very 
                important to understand.
            </p>
            <p>
                To start, let's go back to C/C++
                and look at a structure that works very similar to how
                memory works in MIPS.
            </p>
<pre><code class="c">
int foo[8] = {33, 2, 5, 10, 99, 21, 45, 50}; 
</code></pre>

        <p>
            Yes, that's right arrays. Here we've declared an array of size 8 and
            filled it with some integers. 
        </p>

        <p>
            You know that with arrays, you can index them with integers to get data
            from them
        </p>

<pre><code class="c">
int i = foo[0] // This will set i equal to 33
int j = foo[4] // This will set j equal to 99
</code></pre>

        <p>
            The following illustrates how arrays work:
        </p>

        
        <img src="public/Untitled.svg">
        
        <p>
            We have numerical indicies that we use to retrieve data from our array.
        </p>

        <p>
            If you can understand this, you can understand memory in MIPS. It's the same idea,
            we just give things different names.
        </p>

        <p>
            For example, the numerical indicies (left hand side of our diagram) we use in array are called <strong>memory addresses</strong> when
            talking about memory.
        </p>

        <img src="public/diagram-2.svg" alt="">

        <p>
            <strong>  The array itself <i>is</i> our memory.</strong>  Memory is simply an array. We store data in our memory
            array, just like we do in programming languages like C/C++, and we retrive data from our
            memory with numerical indices, or memory adddresses.
        </p>

        <p>
            Of course this leads to a couple key questions. <i>What data do we store in our memory array?</i>
            <i>How big is our memory array?</i>
        </p>

        <p>
            Let's tackle the first one.
        </p>

        <p>
            The data we can store in MIPS memory are bits. That's it, just 1's and 0's. 
            In MIPS, each memory address maps to 8 bits of data or 1 byte. 
        </p>

        <p>
            Let's convert our numbers in the previous diagram to their bit representations, or to <i>binary:</i>
        </p>

        <img src="public/diagram-3.svg" alt="">

        <p>
            So 33 becomes 00100001, and so on. Notice that no value is bigger than 8-bits. 
            What if I wanted to retrive 33 from my memory? We know it's memory address to be at 0, so
            just like an array, we index our memory at 0 to retrieve that data.
        </p>

        <p>
            In MIPS assembly, it would look like this:
        </p>

<pre><code class="mips">
lw $t0, 0($0)
</code></pre>

    <p>
        Particularly, look at what the last part is saying: 0($0). The zero register 
        holds the value zero. The 0 that is outside the paranthesis is our offset. 
    </p>

    <p>
        Does that sound familar? The offset is identical to our numerical index when using arrays!
    </p>

        <p>
            It's the same idea. Arrays are sequential blocks of memory.
        </p>

        <p>
            But why do we need the $0 register anyways? In order to use the "lw" instruction
            it require a <i>base memory address</i> value that is stored in a register. We can't just do:
        </p>
<pre><code class="mips">
lw $t0, 0 # this won't work!
</code></pre>
        <p>
            Remember, memory addresses are just integers we use to index our memory array.
            The expression 0($0) is calculationg that memory address in the form:
            <i>base address + offset</i>.
            
        </p>

        <p>
            So ask yourself, what is 0 + $0? Well the zero register $0 holds 0, so 0 + 0 is 0.
            Okay, we've calculated our index, or memory address. Now it's time to index our memory array
            and retrieve the value.
        </p>
        <img src="public/diagram-4.svg" alt="">

        <p>
            Look at the left side of our diagram and find memory address (index) 0. We then retrive the
            data stored at that address: 00100001 in binary or 33 in decimal.
        </p>

        <p>
            What if you wanted to retrive the value 01100011 from our memory? Find it's memory in the diagram. Okay
            it's 4. Remember our expression: <i>base address</i> + <i>offset</i> = <i>memory address</i>. To retrive
            our value, we do the following:

        </p>

<pre><code class="mips">
lw $t0, 4($0) 
</code></pre>

<p>
    Base address = 0, offset = 4, memory address = 4 + 0 = 4. We index our memory at 4, and get the value 
    01100001. Simple.

<h2>Machine Words</h2>
<p>
    The discerning may notice a problem with our MIPS code though. The instruction "lw"
    stands for load word. What does that mean really? What is a word?
</p>

<p>
    A <strong>word</strong> or machine word, is the size (in bits) of data a machine's CPU can 
    optimally handle. 
</p>

<p>
    In MIPS, that size is 32-bits. It's no coincidence that registers are also 32-bits in size. 
    So load word loads a word of data, or 32 bits. Why is that a problem? 
</p>

<p>
    Our memory stores 8 bits at each memory address. The reason for this is because MIPS memory
    <strong>byte addressable</strong>. Right, that makes sense, 1 byte at each memory address.
</p>

<p>
    Intergers in MIPS are one word in size, or 32-bits. We can't store an integer in a single memory address, because we
    have only have 8 bits available at a given address. 
</p>
<p>
    Instead, we spread our 32-bit integer across 4 memory addresses. Right, 4 address which hold 8 bits is 32 bits.
    Let's consider an interger, 70. It's 32-bit represenation is as follows:
</p>

<img src="public/diagram-6.svg" alt="">
<p>
    <i>I assume you can convert decimal to binary. If not, use an online converter here, or just take my word.</i>
</p>
<p>

</p>
<p>
    Let's store our integer in our memory, say at memory address 12. In C we would do something like:
</p>

<pre><code class="c">
array[12] = 70;
</code></pre>

    <p>
        In MIPS, we have to store our value 70 in a register first. And then store it in our array.
    </p>
<pre><code class="mips">
li $t0, 70 # store 70 in a register
sw $t0, 12($0) # store at 0 + 12 = memory address 12
</code></pre>

<p>
    Now, let's understand what happens here. We know 70 is 32-bits in size. We cannot store all of it's bits at memory address 12.
    Let's see what MIPS does.
</p>

<img src="public/diagram-8.svg" alt="">

<p>
    We see the 32 bits of 70 are not just in memory address 12, the first 8 bits, or leading bits, are at 12, the next at 13, the next at 14 and finally the last  8 bits at 15.
</p>

<p>
    Remember, load word loads a machine word, or 32 bits. So if I want to retrive my value,
    I would use the following MIPS code:
</p>

<pre><code class="mips">
li $t0, 12 # Storing our memory address in a register

# base address = 12, offset = 0, memory address = 12
lw $t1, 0($t0)
</code></pre>
    <p>
        To really drive home the fact memory address are just integers, we stored the memory address of our 70, 12, in a register.
        That way our offset can just be 0. But what's going here?
    </p>

    <p>
        Load words loads 32 bits of data into a register. Of course, memory address 12 only holds 8 bits of data.
        So what load word does is it starts memory address 12 and stops until it reaches 32 bits.
    </p>

    <ul>
        <li>Memory Address 12: 00000000</li>
        <li>Memory Address 13: 00000000</li>
        <li>Memory Address 14: 00000000</li>
        <li>Memory Address 15: 01000110</li>
        <li>Okay done!</li>
    </ul>

    <p>
        Register can hold 32-bits, so those bits get stored in the register. And just like
        that we've retrived our integer 70. But of course any 32-bit value can be stored in memory:
        strings, return addressess etc.
    </p>
    <h2>Hexadecimal</h2>
    <p>
        It's more common to express memory addressess and data in hexadecimal as these thing get quite large.
        For example, memory address 0xFACBFAFF would be 4207672063 in decimal. That's rather hard to process, let's update our diagram.
    </p>
    <img src="public/diagram-9.svg" alt="">
    <p>
        We converted our binary bits for 70 into hex, and our memory addresses to hex. 70 in hex is 0x00000046 and you can verify it in the diagram.
    </p>
    <p>
        You may be a bit put off by hexadecimal, but remember, it's still just a number. This diagram is equivalent to the other one.
        You may want to get comfortable with thinking in hexadecimal, as you'll find it's often more convenient to represent numbers this way.
    </p>

    <h2>Memory Addresses</h2>
    <p>
       One last thing about memory addresses. We noted we could store memory addresses in registers.
    </p>

    <p>
       Memory addresses themselves can be no larger than 32 bits, they are a word long. That's why can 
       store them in 32-bit registers.
    </p>
    <p>
        Now, to answer our question, <i>how big is our memory array</i>?
    </p>

    <p>
        It's as big as we can index, which is to say it's size is limited by the size of our
        memory addresses. 
    </p>

    <p>
        In hex, the biggest memory address we have in MIPS is 0xFFFFFFFF, where each bit in our 32 bit address is 1.
        Let's convert that to decimal: 2^32 = 4294967296. 
    </p>

    <p>
        What does mean? It means we have 2^32 unique locations to index our memory array.
        Each location can hold 8 bits, so the amount of memory we have access to with our 32 bit memory address is <strong>2^32 bytes</strong> which is about 4 GB.
    </p>

    <h2>Conclusion</h2>
    <p>
        I hope you've gotten a better understanding for how memory is organized in MIPS. Make sure you understand these fundamental ideas, as it's key to understanding MIPS architecture as a whole.
    </p>
        </div>  

        <script src="./vendor/highlight-js/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </body>
<html>